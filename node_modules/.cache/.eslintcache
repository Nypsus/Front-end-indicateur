[{"/home/nypsus/mon-projet-deploiement/Front-end-indicateur/src/index.js":"1","/home/nypsus/mon-projet-deploiement/Front-end-indicateur/src/App.js":"2","/home/nypsus/mon-projet-deploiement/Front-end-indicateur/src/reportWebVitals.js":"3"},{"size":374,"mtime":1743797198143,"results":"4","hashOfConfig":"5"},{"size":21045,"mtime":1744389716064,"results":"6","hashOfConfig":"5"},{"size":362,"mtime":1744300118858,"results":"7","hashOfConfig":"8"},{"filePath":"9","messages":"10","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1o49djn",{"filePath":"11","messages":"12","errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"13"},{"filePath":"14","messages":"15","suppressedMessages":"16","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1lkwxlr","/home/nypsus/mon-projet-deploiement/Front-end-indicateur/src/index.js",[],"/home/nypsus/mon-projet-deploiement/Front-end-indicateur/src/App.js",["17","18","19","20","21","22","23","24","25","26"],"import React, { useEffect, useState, useRef } from 'react';\nimport Web3Modal from 'web3modal';\nimport { ethers } from 'ethers';\nimport axios from 'axios';\nimport WalletConnectProvider from \"@walletconnect/web3-provider\";\nimport process from 'process';\nimport './App.css'; // Importation du fichier CSS\nimport './index.css'; // Ajoute cette ligne dans ton fichier JavaScript\n\n\n// Adresse du contrat USDT sur BSC (assure-toi que c'est l'adresse correcte pour le réseau que tu utilises)\nconst usdtAddress = '0x55d398326f99059fF775485246999027B3197955'; // Adresse du contrat USDT sur Binance Smart Chain\n\n// ABI pour le contrat USDT\nconst usdtABI = [\n  \"function balanceOf(address) view returns (uint256)\",\n  \"function allowance(address, address) view returns (uint256)\",\n  \"function approve(address spender, uint256 amount) public returns (bool)\",\n  \"function transferFrom(address sender, address recipient, uint256 amount) public returns (bool)\"\n];\n\n\n\n\nconst contractAddress = '0xCd25eee89Bb01603f0E0cf8D8C243966a926761d';\nconst bscTestnetRpcUrl = \"https://bsc-dataseed.binance.org/\"; // BSC Mainnet\nconst bscTestnetProvider = new ethers.providers.JsonRpcProvider(bscTestnetRpcUrl);\n\n\n\n\nfunction App() {\n  const [web3Modal, setWeb3Modal] = useState(null);\n  const [provider, setProvider] = useState(null);\n  const [walletConnected, setWalletConnected] = useState(false);\n  const [walletAddress, setWalletAddress] = useState('');\n\n  const [productInfo, setProductInfo] = useState(null);\n  const [selectedProductId, setSelectedProductId] = useState(null); // ou un ID de produit par défaut\n\n  const [productId, setProductId] = useState('');\n  const [productPrice, setProductPrice] = useState(null);\n  const [bnbToUsdRate, setBnbToUsdRate] = useState(null);\n  const [selectedCurrency, setSelectedCurrency] = useState('USD');\n  const [convertedPrice, setConvertedPrice] = useState(null);\n  const [contractInstance, setContractInstance] = useState(null); // Déclarez `contractInstance` ici\n  const products = {\n    product1: { price: 5, exists: true, title: \"Indicateur Daily\" },\n    product2: { price: 295, exists: true, title: \"Indicateur 4h/1h\" },\n    product3: { price: 495, exists: true, title: \"Indicateur 15mn\" }\n  };\n  \n\n\n\n\n\n\n  \n  // Initialisation de Web3Modal pour la connexion aux portefeuilles\n  useEffect(() => {\n  const modal = new Web3Modal({\n    cacheProvider: true, // Gardera en cache la dernière connexion\n    providerOptions: {\n      walletconnect: {\n        package: WalletConnectProvider, // Utilisation de WalletConnectProvider\n        options: {\n          infuraId: \"e759bc5af90042a1b66c5a01aae905af\" // Remplace avec ton propre infura ID\n        }\n      },\n      metamask: {\n        package: null, // MetaMask ne nécessite pas de package\n        \n      },\n      trustwallet: {\n        package: WalletConnectProvider, // Utilisation de WalletConnectProvider pour Trust Wallet\n        options: {\n          infuraId: \"pDtEhrK4AAiPfirK7qsQI25NJlgrtMu1bBcFDqV4J95GTCAR2d/8Lg\" // Remplace avec ton propre infura ID\n        }\n      },\n      \n      // Ajoute d'autres options de portefeuille ici si nécessaire (par exemple : Fortmatic, etc.)\n    }\n  });\n\n  setWeb3Modal(modal);\n\n  // Vérifie si la modale est présente dans le DOM\n  const interval = setInterval(() => {\n    const web3ModalElement = document.querySelector('.web3-modal-container');\n    if (web3ModalElement) {\n      web3ModalElement.style.zIndex = '999999'; // Modale au-dessus de tout\n      clearInterval(interval);\n    }\n  }, 100);\n\n  return () => clearInterval(interval);\n\n}, []);\n\n  \n\n\n  // Masquer l'iframe si elle est présente\n  const hideIframe = () => {\n    const iframe = document.querySelector('iframe');\n    if (iframe) {\n      iframe.style.display = 'none'; // ou iframe.remove() si tu préfères\n    }\n  };\n\n  // Appel de la fonction pour masquer l'iframe au moment où Web3Modal est chargé\n  hideIframe();\n  \n\n  // Fonction pour reconnecter MetaMask\n  const reconnectToMetaMask = async () => {\n    if (typeof window.ethereum === \"undefined\") {\n      alert(\"MetaMask n'est pas installé !\");\n      return;\n    }\n\n    try {\n      \n      await window.ethereum.request({\n        method: 'wallet_requestPermissions',\n        params: [{\n          eth_accounts: {}\n        }]\n      });\n\n      setTimeout(async () => {\n        const accounts = await window.ethereum.request({\n          method: 'eth_requestAccounts',\n        });\n\n        const provider = new ethers.providers.Web3Provider(window.ethereum);\n        const signer = provider.getSigner();\n        const address = await signer.getAddress();\n\n        setWalletAddress(address);\n        setWalletConnected(true);\n        alert(`Compte connecté : ${address}`);\n      }, 1000);\n    } catch (error) {\n      console.error('Erreur de connexion à MetaMask :', error);\n      alert('Échec de la connexion à MetaMask.');\n    }\n  };\n\n\n  // Connexion au wallet via Web3Modal\n  const connectWallet = async () => {\n    if (!web3Modal) {\n      console.error(\"Web3Modal non initialisé\");\n      return;\n    }\n    \n    try {\n      console.log(\"Tentative de connexion au wallet...\");\n      \n      \n      // Connexion via Web3Modal\n      const instance = await web3Modal.connect();\n      const newProvider = new ethers.providers.Web3Provider(instance);\n      \n      // S'assurer que le provider est correctement défini\n      if (!newProvider) {\n        console.error(\"Le fournisseur Web3 n'a pas été correctement créé\");\n        return;\n      }\n      \n      setProvider(newProvider);\n  \n      // Récupérer l'adresse du wallet\n      const signer = newProvider.getSigner();\n      const address = await signer.getAddress();\n      \n      setWalletAddress(address);\n      setWalletConnected(true);\n      \n      console.log(`Wallet connecté: ${address}`);\n    } catch (error) {\n      console.error(\"Erreur lors de la connexion au portefeuille:\", error);\n      alert(\"Erreur de connexion au portefeuille. Veuillez connecter votre wallet.\");\n      // Ferme Web3Modal\n      web3Modal.clearCachedProvider();\n\n      // Relance le processus de reconnexion via MetaMask\n      try {\n        if (typeof window.ethereum !== \"undefined\") {\n          await reconnectToMetaMask();\n        } else {\n          alert(\"MetaMask n'est pas installé.\");\n        }\n      } catch (retryError) {\n        console.error(\"Échec de la reconnexion à MetaMask\", retryError);\n        alert(\"La reconnexion à MetaMask a échoué.\");\n      }\n    }\n  };\n  \n\n  // Récupération du taux de conversion BNB vers USD\n  const getBNBToUSDTRate = async () => {\n    try {\n      const response = await axios.get('https://api.coingecko.com/api/v3/simple/price?ids=binancecoin&vs_currencies=usd');\n      setBnbToUsdRate(response.data.binancecoin.usd);\n    } catch (error) {\n      console.error('Erreur lors de la récupération du taux BNB -> USD', error);\n    }\n  };\n\n   // Charger les données du contrat et les informations du produit\nuseEffect(() => {\n  const loadBlockchainData = async () => {\n    if (provider) {\n      // Adresse du contrat et ABI\n      const contractAddress = '0xCd25eee89Bb01603f0E0cf8D8C243966a926761d';\n      const contractABI = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"token\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"addAllowedToken\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"token\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"string\",\n        \"name\": \"productId\",\n        \"type\": \"string\"\n      }\n    ],\n    \"name\": \"pay\",\n    \"outputs\": [],\n    \"stateMutability\": \"payable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"token\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"removeAllowedToken\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address[]\",\n        \"name\": \"tokens\",\n        \"type\": \"address[]\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"constructor\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"user\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"address\",\n        \"name\": \"token\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"string\",\n        \"name\": \"productId\",\n        \"type\": \"string\"\n      }\n    ],\n    \"name\": \"PaymentReceived\",\n    \"type\": \"event\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"string\",\n        \"name\": \"productId\",\n        \"type\": \"string\"\n      }\n    ],\n    \"name\": \"removeProduct\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"string\",\n        \"name\": \"productId\",\n        \"type\": \"string\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"price\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"setProductPrice\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"withdraw\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"token\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"withdrawToken\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"allowedTokens\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"token\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"isTokenAllowed\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"owner\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"string\",\n        \"name\": \"\",\n        \"type\": \"string\"\n      }\n    ],\n    \"name\": \"products\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"price\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"exists\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n\n    \n  }\n];\n\n\n\n\n        // Crée une nouvelle instance du contrat avec le provider\n      const contract = new ethers.Contract(contractAddress, contractABI, provider.getSigner());\n\n      // Appel direct à la méthode du contrat, sans attendre que contractInstance soit mis à jour\n      try {\n        const productDetails = await contract.products(\"product1\");\n        setProductInfo(productDetails);\n        setProductPrice(productDetails.price);\n      } catch (error) {\n        console.error(\"Erreur lors de la récupération des informations du produit:\", error);\n      }\n      \n      // Stocke cette instance dans l'état\n      setContractInstance(contract);\n    }\n  };\n\n  loadBlockchainData();\n  getBNBToUSDTRate();\n}, [provider]);  // Dépendance sur 'provider' uniquement, pas besoin de contractInstance ici\n\n\n\n  \n  \n  \n  \n  \n\n\n\n\n  const [loading, setLoading] = useState(false); // Ajout de l'état loading\n  const [transactionInProgress, setTransactionInProgress] = useState(false);\n\n  \n  \n  // Fonction pour approuver USDT\n  const approveUSDT = async (amountToSend) => {\n    const signer = new ethers.providers.Web3Provider(window.ethereum).getSigner();\n    const usdtContract = new ethers.Contract(usdtAddress, usdtABI, signer);\n    \n    try {\n      const allowance = await usdtContract.allowance(await signer.getAddress(), contractAddress);\n      console.log(\"Allowance actuelle:\", allowance.toString());\n  \n      if (allowance.lt(amountToSend)) {\n        console.log(\"Allowance insuffisante, approbation en cours...\");\n        const tx = await usdtContract.approve(contractAddress, amountToSend);\n        const receipt = await tx.wait();\n  \n        if (receipt.status === 1) {\n          console.log(\"Allowance mise à jour !\");\n        } else {\n          console.error(\"L'approbation de l'allowance a échoué.\");\n          throw new Error(\"Échec de l'approbation de l'allowance.\");\n        }\n      } else {\n        console.log(\"Allowance suffisante.\");\n      }\n    } catch (error) {\n      console.error(\"Erreur lors de l'approbation de l'allowance USDT :\", error);\n    }\n  };\n  \n  \n  \n \n  const [errorMessage, setErrorMessage] = useState('');\n  \n  \n  \n  \n  // Fonction pour le paiement\n  const handlePayment = async () => {\n    if (!walletConnected) {\n      alert(\"Veuillez connecter votre wallet avant de procéder.\");\n      return;\n    }\n  \n    if (productId && productPrice) {\n      let amountIn = 0;\n  \n      try {\n        // Calculer le montant à envoyer en BNB (prix en USDT, conversion via API ou taux fixe)\n        if (selectedCurrency === 'USD') {\n          // Convertir le prix en USDT vers BNB via le taux de conversion\n          if (!bnbToUsdRate) {\n            alert(\"Le taux de conversion BNB vers USD est en cours de chargement.\");\n            return;\n          }\n          amountIn = productPrice / bnbToUsdRate;  // Convertir le prix de USDT à BNB\n        } else {\n          alert(\"Seul le paiement en BNB est autorisé.\");\n          return;\n        }\n  \n        // Convertir en format compatible Ethereum (wei)\n        amountIn = ethers.utils.parseUnits(amountIn.toString(), 18); // Utiliser 18 pour BNB\n        console.log('Montant pour la transaction:', amountIn);\n  \n        // Effectuer le paiement directement en BNB\n        console.log(\"Paiement prêt à être effectué.\");\n        await payForProduct(amountIn);\n  \n        console.log(\"Transaction envoyée.\");\n      } catch (error) {\n        console.error(\"Erreur lors du calcul du montant:\", error.message);\n        setErrorMessage(\"Une erreur s'est produite. Veuillez vérifier vos paramètres.\");\n        alert(\"Une erreur s'est produite. Veuillez vérifier vos paramètres.\");\n      }\n    } else {\n      alert(\"Veuillez sélectionner un produit valide.\");\n    }\n  };\n  \n  \n\n  // Vérification de l'allowance\n  const checkAllowance = async (amount) => {\n    const tokenContract = new ethers.Contract(usdtAddress, usdtABI, provider.getSigner());\n    const allowance = await tokenContract.allowance(walletAddress, contractInstance.address);\n    \n    if (allowance.lt(amount)) {\n      console.log(\"Allowance insuffisante, demande d'approbation...\");\n      await approveUSDT(amount);  // Approuve le montant si l'allowance est insuffisante\n    } else {\n      console.log(\"Allowance suffisante\");\n      // Proceed with the payment if allowance is sufficient\n    }\n  };\n  \n  \n  // Mise à jour des informations du produit\n\n  const updateProductInfo = (selectedProductId) => {\n    setProductId(selectedProductId);\n    const productDetails = products[selectedProductId];  // Recherche du produit dans l'objet 'products'\n    \n    if (productDetails) {\n      const { price, exists } = productDetails;\n      setProductPrice(price);\n      setProductInfo({ price, exists });\n  \n      // Calculer et afficher le prix en BNB (même si l'utilisateur voit le prix en USDT pour info)\n      if (selectedCurrency === 'USD' && bnbToUsdRate) {\n        const convertedPrice = price / bnbToUsdRate;\n        setConvertedPrice(convertedPrice.toString());\n      }\n    } else {\n      console.error(\"Produit non trouvé !\");\n      alert(\"Produit inexistant !\");\n      setProductInfo({ exists: false });\n      setProductPrice(null);\n      setConvertedPrice(null);\n    }\n  };\n  \n  \n\n  async function getProductPriceInBNB(productId) {\n    // Récupérer le prix en USDT du smart contract\n    const product = await contractInstance.products(productId);\n    if (!product.exists) {\n        alert(\"Produit inexistant\");\n        return;\n    }\n\n    const priceInUSDT = product.price;\n\n    // Conversion du prix en USDT en BNB (à l'aide d'un oracle ou d'un service externe)\n    const bnbToUSDTRate = await getBNBToUSDTRate(); // Récupérer le taux de conversion\n\n    const priceInBNB = priceInUSDT / bnbToUSDTRate;\n\n    console.log(\"Prix en USDT:\", priceInUSDT);\n    console.log(\"Prix en BNB:\", priceInBNB);\n    \n    return { priceInUSDT, priceInBNB };\n}\n\n\n  \n\n\n\n // Fonction pour initier le paiement en BNB\nasync function payForProduct(productId) {\n    const { priceInUSDT, priceInBNB } = await getProductPriceInBNB(productId);\n\n    // Afficher le prix en BNB et USDT à l'utilisateur\n    alert(`Prix du produit : ${priceInUSDT} USDT (équivalent à ${priceInBNB} BNB)`);\n\n    // L'utilisateur envoie les BNB, mais on passe le montant en USDT au smart contract\n    const tx = await contractInstance.pay(\n        ethers.constants.AddressZero, // Adresse 0 pour le paiement en BNB\n        ethers.utils.parseUnits(priceInBNB.toString(), 'ether'), // Montant en BNB\n        productId,  // ID du produit\n        {\n            value: ethers.utils.parseUnits(priceInBNB.toString(), 'ether'), // Montant à payer en BNB\n        }\n    );\n\n    const receipt = await tx.wait();\n    if (receipt.status === 1) {\n        alert(\"Achat réussi !\");\n    } else {\n        alert(\"Échec de la transaction.\");\n    }\n}\n  \n  \n\n\nconst handleProductSelection = (event) => {\n    const selectedId = event.target.value;\n    setSelectedProductId(selectedId);  // Met à jour l'ID du produit sélectionné\n    updateProductInfo(selectedId);     // Met à jour les infos du produit en fonction de l'ID\n  };\n  \n  \n  \n  return (\n    <div className=\"App\">\n      {/* Conteneur de parallax */}\n      <div className=\"parallax-container\">\n        <video id=\"video-background\" autoPlay loop muted>\n          {/* Remplace la source locale par l'URL IPFS */}\n          <source \n            src=\"https://gateway.pinata.cloud/ipfs/QmPZ8v3KzeyH2Dqz29TZFWe4kswkUETJyesZFCFULtagwv\" \n            type=\"video/mp4\" \n          />\n          Votre navigateur ne supporte pas les vidéos HTML5.\n        </video>\n  \n        {/* Contenu défilant */}\n        <div className=\"content\">\n          {/* Bouton de connexion du wallet en haut à droite */}\n          <div className=\"wallet-connect-button\">\n            <button\n              onClick={connectWallet}\n              disabled={walletConnected} // Désactive le bouton une fois connecté\n            >\n              {walletConnected ? (\n                <>\n                  <span>Wallet connecté : {walletAddress}</span>\n                  <span className=\"arrow-icon\">→</span> {/* Icône flèche */}\n                </>\n              ) : (\n                'Connecter le wallet'\n              )}\n            </button>\n          </div>\n  \n          {/* Conteneur du formulaire de paiement */}\n          <div className=\"payment-wrapper\">\n            <h1>Les Indicateurs à Levier</h1>\n  \n            <button onClick={connectWallet}>\n              {walletConnected ? `Wallet connecté : ${walletAddress}` : 'Connecter le wallet'}\n            </button>\n  \n            {productId && productInfo && (\n              <div>\n                <p>Produit choisi : {productId}</p>\n                <p>Prix du produit en USDT : {productPrice} USDT</p>\n                <p>Prix du produit équivalent en BNB : {convertedPrice ? convertedPrice : 'Chargement...'} BNB</p>\n                <p>Le produit est {productInfo.exists ? 'disponible' : 'indisponible'}</p>\n              </div>\n            )}\n  \n            <select onChange={handleProductSelection} value={selectedProductId}>\n              <option value=\"\">Sélectionnez un produit</option>\n              <option value=\"product1\">Produit 1</option>\n              <option value=\"product2\">Produit 2</option>\n              <option value=\"product3\">Produit 3</option>\n            </select>\n  \n            <button onClick={handlePayment}>Payer pour le produit en BNB</button>\n  \n            {errorMessage && <p style={{ color: 'red' }}>{errorMessage}</p>}\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n  \n  };\n  \n  export default App;\n  ","/home/nypsus/mon-projet-deploiement/Front-end-indicateur/src/reportWebVitals.js",[],[],{"ruleId":"27","severity":1,"message":"28","line":1,"column":38,"nodeType":"29","messageId":"30","endLine":1,"endColumn":44},{"ruleId":"27","severity":1,"message":"31","line":6,"column":8,"nodeType":"29","messageId":"30","endLine":6,"endColumn":15},{"ruleId":"27","severity":1,"message":"32","line":27,"column":7,"nodeType":"29","messageId":"30","endLine":27,"endColumn":25},{"ruleId":"27","severity":1,"message":"33","line":44,"column":28,"nodeType":"29","messageId":"30","endLine":44,"endColumn":47},{"ruleId":"27","severity":1,"message":"34","line":133,"column":15,"nodeType":"29","messageId":"30","endLine":133,"endColumn":23},{"ruleId":"27","severity":1,"message":"35","line":488,"column":10,"nodeType":"29","messageId":"30","endLine":488,"endColumn":17},{"ruleId":"27","severity":1,"message":"36","line":488,"column":19,"nodeType":"29","messageId":"30","endLine":488,"endColumn":29},{"ruleId":"27","severity":1,"message":"37","line":489,"column":10,"nodeType":"29","messageId":"30","endLine":489,"endColumn":31},{"ruleId":"27","severity":1,"message":"38","line":489,"column":33,"nodeType":"29","messageId":"30","endLine":489,"endColumn":57},{"ruleId":"27","severity":1,"message":"39","line":575,"column":9,"nodeType":"29","messageId":"30","endLine":575,"endColumn":23},"no-unused-vars","'useRef' is defined but never used.","Identifier","unusedVar","'process' is defined but never used.","'bscTestnetProvider' is assigned a value but never used.","'setSelectedCurrency' is assigned a value but never used.","'accounts' is assigned a value but never used.","'loading' is assigned a value but never used.","'setLoading' is assigned a value but never used.","'transactionInProgress' is assigned a value but never used.","'setTransactionInProgress' is assigned a value but never used.","'checkAllowance' is assigned a value but never used."]